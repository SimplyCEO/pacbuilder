#!/bin/sh

PROJECT_NAME=$(basename $0)
PROJECT_VERSION="0.0.9"
REPO_FOLDER="${HOME}/.cache/pacbuilder"
mkdir -p "${REPO_FOLDER}"

REPOSITORIES=""
if [ -f "/etc/pacbuilder.d/mirrorlist" ]; then REPOSITORIES=$(grep -v "#" /etc/pacbuilder.d/mirrorlist); fi
if [ -z "${REPOSITORIES}" ]; then REPOSITORIES="https://gitlab.archlinux.org/archlinux/packaging/packages"; fi

SKIP_PGP_SIGNATURE=""

# core #

char()
{
  echo "$2" | cut -c $1
}

strncmp()
{
  if [ -z $1 ] || [ -z $2 ] || [ -z $3 ]; then echo 1; return 1; fi

  local c=1
  while [ $c -le $3 ]; do
    if [ $(char $c $1) != $(char $c $2) ]; then echo 1; return 1; fi
    c=$((c+1))
  done

  echo 0; return 0
}

strlen()
{
  echo "$1" | wc -c
}

# tools #

array()
{
  local index=$1; shift
  local string="$@"

  local i=0
  for array in $(echo "${string}" | cut -d " " -f 1-5000); do
    if [ $i -eq $index ]; then echo "${array}"; return 0; fi
    i=$((i+1))
  done

  return 1
}

# pacbuilder #

fhelp()
{
  local EXTRA_FLAG=$1

  if [ $(strncmp "${EXTRA_FLAG}" "-h" 2) = 0 ] || [ $(strncmp "${EXTRA_FLAG}" "--help" 6) = 0 ]; then
    printf "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n"                                   \
      "usage:  ${PROJECT_NAME} {-B --build} [options] [package(s)]"                 \
      "options:"                                                                    \
      "  -u, --upgrade        clean and upgrade the contents of each package."      \
      "      --clean          clean the contents of each given package."            \
      "      --list           list the existing packages from the build directory"  \
      "                       or their contents, if provided name."                 \
      "      --edit           edit PKGBUILD before compiling."                      \
      "                       the modification will be stored as a patch file."     \
      "      --skippgpcheck   skip PGP key signature checking: not recommended."
  else
    pacman --help | head -n 11 | sed "s/pacman/${PROJECT_NAME}/g"
    printf "    ${PROJECT_NAME} {-B --build}    [options] [package(s)]\n\n"
    pacman --help | tail -n 1 | sed "s/pacman/${PROJECT_NAME}/g"
  fi

  return 0
}

fversion()
{
  printf "%s\n%s\n%s\n%s\n%s\n%s\n"                                                         \
    "  .--.                  Pacbuilder v${PROJECT_VERSION}"                                             \
    " / _.-' .-.  .-.  .-.   Copyright (C) 2025 SimplyCEO <simplyceo.developer@gmail.com>"  \
    " \\  '-. '-'  '-'  '-'"                                                                \
    "  '--'"                                                                                \
    "                        This application may be freely redistributed under"            \
    "                        the terms of the Open Software License 3.0."

  return 0
}

list_clone_directory()
{
  local PACKAGE=$1
  local SILENT=$2

  if [ ! -z $SILENT ] && [ $SILENT -eq 1 ]; then
    if [ -z "${PACKAGE}" ] || [ "${PACKAGE}" = "NULL" ]; then
      if [ -d "${REPO_FOLDER}" ]; then return 0; else return 1; fi
    else
      if [ -d "${REPO_FOLDER}/${PACKAGE}" ]; then return 0; else return 1; fi
    fi
  else
    if [ -z "${PACKAGE}" ] || [ "${PACKAGE}" = "NULL" ]; then
      ls "${REPO_FOLDER}"
    else
      ls "${REPO_FOLDER}/${PACKAGE}" 2>/dev/null
    fi
  fi

  return $?
}

get_editor()
{
  if [ -z $EDITOR ]; then
    local EDITOR_ARRAY="vim vi nano neovim ed"
    for editor in $(echo "${EDITOR_ARRAY}" | cut -d " " -f 1-5); do
      if which $editor >/dev/null 2>&1; then echo $editor; return 0; fi
    done
  else
    echo $EDITOR
    return 0
  fi

  return 1
}

install_package()
{
  local PACKAGE=$1

  cd "${REPO_FOLDER}/${PACKAGE}"
  printf "\033[1;34m::\033[0m \033[1mPackage built successfully, installing... "
  su -c "pacman -U *.pkg.tar.* && mv *.pkg.tar.* /var/cache/pacman/pkg"

  return 0
}

build_package()
{
  local PACKAGE=$1

  cd "${REPO_FOLDER}/${PACKAGE}"
  for data in $(/bin/ls); do
    if [ "${data}" = "PKGBUILD.patch" ]; then
      patch -N PKGBUILD < PKGBUILD.patch > /dev/null 2>&1
      makepkg -g >> PKGBUILD
    fi
  done
  makepkg -s "${SKIP_PGP_SIGNATURE}"

  return $?
}

clean_package()
{
  local PACKAGE=$1

  if [ "${PACKAGE}" != "NULL" ] && [ ! -z "${PACKAGE}" ]; then
    cd "${REPO_FOLDER}/${PACKAGE}"
    rm -rf src/*build*
    rm -f *.tar.*
    cd - >/dev/null 2>&1
  else
    printf "\033[1;33m::\033[0m \033[1mWARNING: No packages given to be cleaned. Do you want to clean the entire folder? [y/N] \033[0m\n"
    local DEFAULT_RESPONSE="n"
    read RESPONSE
    if [ -z "${RESPONSE}" ]; then RESPONSE="${DEFAULT_RESPONSE}"; fi
    case $(char 1 $(echo "${RESPONSE}" | tr '[:upper:]' '[:lower:]')) in
      n)
        exit 1
        ;;
      y)
        cd "${REPO_FOLDER}"
        for folder in $(/bin/ls); do
          rm -rf "${folder}"
        done
        cd - >/dev/null 2>&1
        ;;
      *)
        exit 1
        ;;
    esac
  fi

  return 0
}

clone_package()
{
  local PACKAGE=$1
  local UPGRADE=$2
  local EDIT=$3

  if [ ! -f "${REPO_FOLDER}/${PACKAGE}/PKGBUILD" ]; then
    printf "\033[1;34m::\033[0m \033[1mAttempting to download ${PACKAGE}...\033[0m\n"

    for GITURL in $(echo "${REPOSITORIES}" | cut -d " " -f 1-500); do
      if [ ! -z "${GITURL}" ]; then
        if [ $(echo "${GITURL}" | grep "aur") ]; then
          printf "\033[1;33m::\033[0m \033[1mWARNING: Searching for ${PACKAGE} in AUR. It is recommended to --edit and read the PKGBUILD before continuing...\033[0m\n"
          printf "\033[1;33m::\033[0m \033[1m         Do you want to cancel this request? [Y/n]\033[0m "
          local DEFAULT_RESPONSE="y"
          read RESPONSE
          if [ -z "${RESPONSE}" ]; then RESPONSE="${DEFAULT_RESPONSE}"; fi
          case $(char 1 $(echo "${RESPONSE}" | tr '[:upper:]' '[:lower:]')) in
            n) ;;
            y) exit 1 ;;
            *) exit 1 ;;
          esac
        fi
        GIT_TERMINAL_PROMPT=0 git clone ${GITURL}/${PACKAGE}.git ${REPO_FOLDER}/${PACKAGE} >/dev/null 2>&1
        if [ $? -eq 0 ]; then break; fi
      fi
    done

    if [ ! -d "${REPO_FOLDER}/${PACKAGE}" ]; then
      printf "\033[1;33m::\033[0m \033[1mWARNING: ${PACKAGE} not found in any of the repositories! Skipping...\033[0m\n"
      return 1
    fi

    cd "${REPO_FOLDER}/${PACKAGE}"
    if [ ! -z $EDIT ] && [ $EDIT -eq 1 ]; then edit_package ${PACKAGE}; fi
    makepkg --printsrcinfo > .SRCINFO
    cd - >/dev/null 2>&1

    printf "\033[1;32m::\033[0m \033[1m${PACKAGE} was succesfully downloaded. Building...\033[0m\n"
  else
    printf "\033[1;34m::\033[0m \033[1m${PACKAGE} already exists. Building...\033[0m\n"

    # Update repository
    cd "${REPO_FOLDER}/${PACKAGE}"

    git restore .
    if [ ! -z $UPGRADE ] && [ $UPGRADE -eq 1 ]; then git pull; fi
    if [ ! -z $EDIT ] && [ $EDIT -eq 1 ]; then edit_package ${PACKAGE}; fi
    if [ ! -f .SRCINFO ]; then makepkg --printsrcinfo > .SRCINFO; fi
    cd - >/dev/null 2>&1
  fi

  return 0
}

edit_package()
{
  local PACKAGE=$1

  if [ ! -z "${PACKAGE}" ]; then
    cd "${REPO_FOLDER}/${PACKAGE}"
    local SKIP_EDIT=0
    if [ -f "PKGBUILD.patch" ]; then
      printf "\033[1;33m::\033[0m \033[1mWARNING: A patch file for PKGBUILD has been found. What do you want to do? [DELETE/read/skip]\033[0m\n"
      local RESPONSE=""
      local DEFAULT_RESPONSE="delete"
      read RESPONSE
      if [ -z "${RESPONSE}" ]; then RESPONSE="${DEFAULT_RESPONSE}"; fi
      RESPONSE=$(echo "${RESPONSE}" | tr '[:upper:]' '[:lower:]')
      case "${RESPONSE}" in
        skip) SKIP_EDIT=1 ;;
        read)
          SKIP_EDIT=1
          patch -N PKGBUILD < PKGBUILD.patch > /dev/null 2>&1
          cat PKGBUILD | less
          ;;
        delete|*) rm PKGBUILD.patch ;;
      esac
    fi

    if [ $SKIP_EDIT -eq 0 ]; then
      git restore PKGBUILD
      cp PKGBUILD PKGBUILD.editor
      local EDITOR=$(get_editor)
      if [ ! -z $EDITOR ]; then
        $EDITOR PKGBUILD.editor
        if [ ! -z "$(diff PKGBUILD PKGBUILD.editor)" ]; then
          diff PKGBUILD PKGBUILD.editor > PKGBUILD.patch
          printf "\033[1;32m::\033[0m \033[1mA patch for PKGBUILD has succesfully been created.\033[0m\n"
        fi
        rm PKGBUILD.editor
      fi
    fi
    cd - >/dev/null 2>&1
  else
    return 1
  fi

  return 0
}

run_pacman()
{
  pacman $@
}

build_packages()
{
  clone_package "$1" $2
  if [ $? -ne 1 ]; then
    build_package "$1"
    if [ $? -eq 0 ]; then
      install_package "$1"
    fi
  fi
  return 0
}

clean_packages()
{
  list_clone_directory $1 1
  if [ $? -eq 0 ]; then
    clean_package $1
  fi
  return 0
}

edit_packages()
{
  clone_package $1 0 1
  if [ $? -ne 1 ]; then
    build_package $1
    if [ $? -eq 0 ]; then
      install_package $1
    fi
  fi
  return 0
}

list_packages()
{
  list_clone_directory $1
  if [ $? -ne 0 ]; then
    printf "\033[1;31m::\033[0m \033[1mERROR: $1 package not found in clone directory.\n"
    return 1
  fi
  return 0
}

upgrade_packages()
{
  list_clone_directory "$1" 1
  if [ $? -eq 0 ]; then
    clean_package "$1"
    build_packages "$1" 1
  fi
}

if [ $# -lt 1 ]; then fhelp; exit 1; fi

OPTIONS="$@"
FLAG_CALL=$(array 0 "${OPTIONS}")
case "${FLAG_CALL}" in
  -h|--help) fhelp; exit 0 ;;
  -V|--version) fversion; exit 0 ;;
  -B|-Bu|--build)
    EXTRA_OPTION=0
    LIST_PACKAGES=0
    CLEAN_PACKAGES=0
    EDIT_PACKAGES=0
    UPGRADE_PACKAGES=0

    case "${FLAG_CALL}" in
      -Bu) UPGRADE_PACKAGES=1 ;;
      *) if [ $# -lt 2 ]; then fhelp; exit 1; fi ;;
    esac

    shift 1

    for extra_option in "$@"; do
      if [ $(char 1 "${extra_option}") != "-" ]; then break; fi
      case "${extra_option}" in
        # Clean package directory.
        --clean) CLEAN_PACKAGES=1 ;;
        # List packages from clone directory.
        --list) LIST_PACKAGES=1 ;;
        --edit) EDIT_PACKAGES=1 ;;
        --skippgpcheck) SKIP_PGP_SIGNATURE="--skippgpcheck" ;;
        -u|--upgrade) UPGRADE_PACKAGES=1 ;;
        *) fhelp "${extra_option}"; exit 0 ;;
      esac
      EXTRA_OPTION=1
      shift 1
    done

    if [ ! -z "$@" ]; then
      for package in $(echo "$@" | cut -d " " -f 1-5000); do
        if [ $EXTRA_OPTION -eq 1 ]; then
          if [ $CLEAN_PACKAGES -eq 1 ]; then clean_packages "${package}"; fi
          if [ $EDIT_PACKAGES -eq 1 ]; then edit_packages "${package}"; fi
          if [ $LIST_PACKAGES -eq 1 ]; then list_packages "${package}"; fi
          if [ $UPGRADE_PACKAGES -eq 1 ]; then upgrade_packages "${package}"; fi
        else
          case "${FLAG_CALL}" in
            -B|--build) build_packages "${package}" ;;
            -Bu) upgrade_packages "${package}" ;;
          esac
        fi
      done
    else
      # Clean packages directory.
      if [ $CLEAN_PACKAGES -eq 1 ] && [ $UPGRADE_PACKAGES -ne 1 ]; then clean_packages NULL; fi
      # Upgrade all packages inside clone directory.
      if [ $UPGRADE_PACKAGES -eq 1 ]; then
        for package in $(ls "${REPO_FOLDER}"); do
          upgrade_packages "${package}"
        done
      fi
    fi
    ;;
  *) run_pacman "$@"; break ;;
esac

