#!/bin/sh

PROJECT_NAME=$(basename $0)
REPO_FOLDER="${HOME}/.cache/pacbuilder"
mkdir -p "${REPO_FOLDER}"

REPOSITORIES=$(grep -v "#" /etc/pacbuilder.d/mirrorlist)
if [ -z "${REPOSITORIES}" ]; then REPOSITORIES="https://gitlab.archlinux.org/archlinux/packaging/packages"; fi

# core #

char()
{
  echo "$2" | cut -c $1
}

strncmp()
{
  if [ -z $1 ] || [ -z $2 ] || [ -z $3 ]; then echo 1; return 1; fi

  local c=1
  while [ $c -le $3 ]; do
    if [ $(char $c $1) != $(char $c $2) ]; then echo 1; return 1; fi
    c=$((c+1))
  done

  echo 0; return 0
}

strlen()
{
  echo "$1" | wc -c
}

# tools #

array()
{
  local index=$1; shift
  local string="$@"

  local i=0
  for array in $(echo "${string}" | cut -d " " -f 1-500); do
    if [ $i -eq $index ]; then echo "${array}"; return 0; fi
    i=$((i+1))
  done

  return 1
}

# pacbuilder #

fhelp()
{
  local EXTRA_FLAG=$1

  if [ $(strncmp "${EXTRA_FLAG}" "-h" 2) = 0 ] || [ $(strncmp "${EXTRA_FLAG}" "--help" 6) = 0 ]; then
    printf "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n"                                       \
      "usage:  ${PROJECT_NAME} {-B --build} [options] [package(s)]"                 \
      "options:"                                                                    \
      "  -u, --upgrade        clean and upgrade the contents of each package."      \
      "      --clean          clean the contents of each given package."            \
      "      --list           list the existing packages from the build directory"  \
      "                       or their contents, if provided name."                 \
      "      --edit           edit PKGBUILD before compiling."                      \
      "                       the modification will be stored as a patch file."
  else
    pacman --help | head -n 11 | sed "s/pacman/${PROJECT_NAME}/g"
    printf "    ${PROJECT_NAME} {-B --build}    [options] [package(s)]\n\n"
    pacman --help | tail -n 1 | sed "s/pacman/${PROJECT_NAME}/g"
  fi

  return 0
}

fversion()
{
  printf "%s\n%s\n%s\n%s\n%s\n%s\n"                                                         \
    "  .--.                  Pacbuilder v0.0.4"                                             \
    " / _.-' .-.  .-.  .-.   Copyright (C) 2025 SimplyCEO <simplyceo.developer@gmail.com>"  \
    " \\  '-. '-'  '-'  '-'"                                                                \
    "  '--'"                                                                                \
    "                        This application may be freely redistributed under"            \
    "                        the terms of the Open Software License 3.0."

  return 0
}

list_clone_directory()
{
  local PACKAGE=$1
  local SILENT=$2

  if [ ! -z $SILENT ] && [ $SILENT -eq 1 ]; then
    if [ -z "${PACKAGE}" ] || [ "${PACKAGE}" = "NULL" ]; then
      if [ -d "${REPO_FOLDER}" ]; then return 0; else return 1; fi
    else
      if [ -d "${REPO_FOLDER}/${PACKAGE}" ]; then return 0; else return 1; fi
    fi
  else
    if [ -z "${PACKAGE}" ] || [ "${PACKAGE}" = "NULL" ]; then
      ls "${REPO_FOLDER}"
    else
      ls "${REPO_FOLDER}/${PACKAGE}" 2>/dev/null
    fi
  fi

  return $?
}

get_editor()
{
  if [ -z $EDITOR ]; then
    local EDITOR_ARRAY="vim vi nano neovim ed"
    for editor in $(echo "${EDITOR_ARRAY}" | cut -d " " -f 1-500); do
      if which $editor >/dev/null 2>&1; then echo $editor; return 0; fi
    done
  else
    return 0
  fi

  return 1
}

install_package()
{
  local PACKAGE=$1

  cd "${REPO_FOLDER}/${PACKAGE}"
  printf "\033[1;34m::\033[0m \033[1mPackage built successfully, installing... "
  su -c "pacman -U *.pkg.tar.* && mv *.pkg.tar.* /var/cache/pacman/pkg"

  return 0
}

build_package()
{
  local PACKAGE=$1

  cd "${REPO_FOLDER}/${PACKAGE}"
  for data in $(/bin/ls); do
    if [ "${data}" = "PKGBUILD.patch" ]; then
      patch -N PKGBUILD < PKGBUILD.patch > /dev/null 2>&1
      makepkg -g >> PKGBUILD
    fi
  done
  makepkg -s --skippgpcheck

  return $?
}

clean_package()
{
  local PACKAGE=$1

  if [ "${PACKAGE}" != "NULL" ] && [ ! -z "${PACKAGE}" ]; then
    cd "${REPO_FOLDER}/${PACKAGE}"
    rm -rf src/*build*
    cd -
  else
    printf "\033[1;33m::\033[0m \033[1mWARNING: No packages given to be cleaned. Do you want to clean the entire folder? [y/N] \033[0m\n"
    DEFAULT_RESPONSE="n"
    read RESPONSE
    if [ -z "${RESPONSE}" ]; then RESPONSE="${DEFAULT_RESPONSE}"; fi
    case $(char 1 $(echo "${RESPONSE}" | tr '[:upper:]' '[:lower:]')) in
      n)
        exit 1
        ;;
      y)
        cd "${REPO_FOLDER}"
        for folder in $(/bin/ls); do
          rm -rf "${folder}"
        done
        cd -
        ;;
      *)
        exit 1
        ;;
    esac
  fi

  return 0
}

clone_package()
{
  local PACKAGE=$1
  local UPGRADE=$2

  if [ ! -f "${REPO_FOLDER}/${PACKAGE}/PKGBUILD" ]; then
    printf "\033[1;34m::\033[0m \033[1mAttempting to download ${PACKAGE}...\033[0m\n"

    for GITURL in $(echo "${REPOSITORIES}" | cut -d " " -f 1-500); do
      if [ ! -z "${GITURL}" ]; then
        GIT_TERMINAL_PROMPT=0 git clone ${GITURL}/${PACKAGE}.git ${REPO_FOLDER}/${PACKAGE} >/dev/null 2>&1
      fi
    done

    if [ ! -d "${REPO_FOLDER}/${PACKAGE}" ]; then
      printf "\033[1;33m::\033[0m \033[1mWARNING: ${PACKAGE} not found in any of the repositories! Skipping...\033[0m\n"
      return 1
    fi

    printf "\033[1;32m::\033[0m \033[1m${PACKAGE} was succesfully downloaded. Building...\033[0m\n"
    if [ ! -f .SRCINFO ]; then makepkg --printsrcinfo > .SRCINFO; fi
  else
    printf "\033[1;34m::\033[0m \033[1m${PACKAGE} already exists. Building...\033[0m\n"

    # Update repository
    cd "${REPO_FOLDER}/${PACKAGE}"

    git restore .
    if [ ! -z $UPGRADE ] && [ $UPGRADE -eq 1 ]; then git pull; fi
    makepkg --printsrcinfo > .SRCINFO
    cd -
  fi

  return 0
}

edit_package()
{
  local PACKAGE=$1

  if [ ! -z "${PACKAGE}" ]; then
    cd "${REPO_FOLDER}/${PACKAGE}"
    SKIP_EDIT=0
    if [ -f "PKGBUILD.patch" ]; then
      printf "\033[1;33m::\033[0m \033[1mWARNING: A patch file for PKGBUILD has been found. What do you want to do? [DELETE/read/skip]\033[0m\n"
      DEFAULT_RESPONSE="delete"
      read RESPONSE
      if [ -z "${RESPONSE}" ]; then RESPONSE="${DEFAULT_RESPONSE}"; fi
      case "${RESPONSE}" in
        skip)
          SKIP_EDIT=1
          ;;
        read)
          SKIP_EDIT=1
          patch -N PKGBUILD < PKGBUILD.patch > /dev/null 2>&1
          cat PKGBUILD | less
          ;;
        delete)
          rm -f PKGBUILD.patch
          ;;
        *)
          rm -f PKGBUILD.patch
          ;;
      esac
    fi

    if [ $SKIP_EDIT -eq 0 ]; then
      git restore PKGBUILD
      cp PKGBUILD PKGBUILD.editor
      local EDITOR=get_editor
      if [ $? -eq 0 ]; then
        $EDITOR PKGBUILD.editor
        if [ ! -z "$(diff PKGBUILD PKGBUILD.editor)" ]; then
          diff PKGBUILD PKGBUILD.editor > PKGBUILD.patch
          printf "\033[1;32m::\033[0m \033[1mA patch for PKGBUILD has succesfully been created.\033[0m\n"
        fi
        rm PKGBUILD.editor
      fi
    fi
    cd -
  else
    return 1
  fi

  return 0
}

run_pacman()
{
  pacman $@
}

build_packages()
{
  clone_package "$1"
  if [ $? -ne 1 ]; then
    build_package "$1"
    if [ $? -eq 0 ]; then
      install_package "$1"
    fi
  fi
  return 0
}

clean_packages()
{
  list_clone_directory $1 1
  if [ $? -eq 0 ]; then
    clean_package $1
  fi
  return 0
}

edit_packages()
{
  clone_package $1
  if [ $? -ne 1 ]; then
    edit_package $1
    build_package $1
    if [ $? -eq 0 ]; then
      install_package $1
    fi
  fi
  return 0
}

list_packages()
{
  list_clone_directory $1
  if [ $? -ne 0 ]; then
    printf "\033[1;31m::\033[0m \033[1mERROR: $1 package not found in clone directory.\n"
    return 1
  fi
  return 0
}

upgrade_packages()
{
  list_clone_directory "$1" 1
  if [ $? -eq 0 ]; then
    clean_package "$1"
    clone_package "$1" 1
    if [ $? -ne 1 ]; then
      build_package "$1"
      if [ $? -eq 0 ]; then
        install_package "$1"
      fi
    fi
  fi
}

if [ $# -lt 1 ]; then fhelp; exit 1; fi

OPTIONS="$@"
case $(array 0 "${OPTIONS}") in
  -h|--help) fhelp; shift ;;
  -V|--version) fversion; shift ;;
  -B|-Bu|--build)
    if [ $# -lt 2 ]; then fhelp; exit 1; fi

    shift
    EXTRA_OPTION="$1"

    case "${EXTRA_OPTION}" in
    --clean|--edit|--list|--upgrade)
      shift
      EXTRA_PACKAGES="$@"
      if [ ! -z "${EXTRA_PACKAGES}" ]; then
        for package in $(echo "${EXTRA_PACKAGES}" | cut -d " " -f 1-500); do
          case "${EXTRA_OPTION}" in
            # List packages from clone directory.
            --list) list_packages "${package}" ;;
            # Clean package directory.
            --clean) clean_packages "${package}" ;;
            --edit) edit_packages "${package}" ;;
            --upgrade) upgrade_packages "${package}" ;;
          esac
        done
        exit 0
      fi

      # Clean packages directory.
      case "${EXTRA_OPTION}" in
        --clean) clean_packages NULL; exit 0 ;;
      esac

      list_clone_directory
      exit 0
      ;;
    # Provide help for building.
    -h|--help)
      fhelp "${EXTRA_OPTION}"
      exit 0
      ;;
    esac

    PACKAGES="$@"
    ;;
  *) run_pacman "$@"; break ;;
esac

if [ ! -z "${PACKAGES}" ]; then
  for PKG in "${PACKAGES}"; do
    case $(array 0 "${OPTIONS}") in
      -B|--build) build_packages "${PKG}" ;;
      -Bu) upgrade_packages "${PKG}" ;;
    esac
  done
fi

